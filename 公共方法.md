# 公共方法


## es6中的find filter 在数组中查找对象

~~~js
var aa=[{id:1,name:'张三'},{id:2,name:'李四'},{id:3,name:'王五'},{id:2,name:'赵六'}]
~~~


+ 数组的方法find

~~~js
aa.find( t=> t.id=='2')  
console.log(bb)// 结果：{id:2,name:'李四'}
// find只会返回第一个满足条件的 而且返回的是对象
~~~

+ 数组的方法filter

~~~js
let bb = aa.filter( t=> t.id=='2')
console.log(bb)  // 结果 [{id:2,name:'李四'},{id:2,name:'赵六'}]
// filter会满足所有符合条件的   返回的还是数组
~~~

## 原生

```js

function removeItem(src, cb) {
 
  var counter = src.length - 1;

  while (true) {

      var result = cb(src[counter]);

      if (result) {

          src.splice(counter, 1);

          counter = src.length - 1;
      } else {
          counter--;
      }

      if (counter < 0) {
          break;
      }
  }
}

var testData = [1, 2, 3, 5, 5, 6, 6, 7, 8, 9, 10];

removeItem(testData, c => c % 2 == 0);

console.log(testData);
```

## 求两个数组的差集

原生

```js
var exclude = (select = [], exclude = []) => {
  for (var i = 0; i < exclude.length; i++) {
    for (var j = 0; j < select.length; j++) {
      if (select[j] == exclude[i]) {
        select.splice(j, 1)
        j = j - 1
      }
    }
  }
  return select
}

```

ES6

```js
const subSet = (arr1, arr2) => {
  var set1 = new Set(arr1)
  var set2 = new Set(arr2)

  var subset = []

  for (const item of set1) {
    if (!set2.has(item)) {
      subset.push(item)
    }
  }

  return subset
}
```

## 求两个数组的交集

```js
var arr1 = [0,2,3,4,6,7,9]
var arr2 = [1,2,3,5,6,8]

var res = [...new Set(arr1)].filter(item => arr2.includes(item))
console.log(res)
```

## 数组对象去重


```js
const unique = (arr, key) => {
  return [...new Map(arr.map(item => [item[key], item])).values()]
}
```

## 美化金钱

```js
const ThousandNum = num => num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
const money = ThousandNum(20190214);
// money => "20,190,214"
```

## 将键值对拼接成URL带参数

```js
const fnParams2Url = obj=> {
	let aUrl = []
	let fnAdd = function(key, value) {
		return key + '=' + value
	}
	for (var k in obj) {
		aUrl.push(fnAdd(k, obj[k]))
	}
	return encodeURIComponent(aUrl.join('&'))
}
```

## 操作URL查询参数

```js
const params = new URLSearchParams(location.search.replace(/\?/ig, "")); // location.search = "?name=young&sex=male"
params.has("young"); // true
params.get("sex"); // "male"
```

## 时间戳

```js
const timestamp = +new Date("2019-02-14");
// timestamp => 155010240000
```

## 精确小数

```js
const RoundNum = (num, decimal) => Math.round(num * 10 ** decimal) / 10 ** decimal;
const num = RoundNum(1.69, 1);
// num => 1.7
```

## 是否空对象

```js
const obj = {};
const flag = DataType(obj, "object") && !Object.keys(obj).length;
// flag => true
```

## 满足条件时执行

```js
const flagA = true; // 条件A
const flagB = false; // 条件B
(flagA || flagB) && Func(); // 满足A或B时执行
(flagA || !flagB) && Func(); // 满足A或不满足B时执行
flagA && flagB && Func(); // 同时满足A和B时执行
flagA && !flagB && Func(); // 满足A且不满足B时执行
```

## 对象不为空时执行

```js
const obj = { a: 0, b: 1, c: 2 };
Object.keys(obj).length && Func();
```

## 函数退出代替条件分支退出

```js
if (flag) {
    Func();
    return false;
}
// 换成
if (flag) {
    return Func();
}
```

## switch/case使用区间

```js
const age = 26;
switch (true) {
    case isNaN(age):
        console.log("not a number");
        break;
    case (age < 18):
        console.log("under age");
        break;
    case (age >= 18):
        console.log("adult");
        break;
    default:
        console.log("please set your age");
        break;
}
```

## 克隆对象

```js
const _obj = { a: 0, b: 1, c: 2 }; // 以下方法任选一种
const obj = { ..._obj };
```

## 环境变量

```js
const env = "prod";
const link = {
    dev: "Development Address",
    test: "Testing Address",
    prod: "Production Address"
}[env];
// link => "Production Address"
```

## 解构对象属性嵌套

```js
const obj = { a: 0, b: 1, c: { d: 2, e: 3 } };
const { c: { d, e } } = obj;
// d e => 2 3
```

## 判断数据类型

```bash
可判断类型：undefined、null、string、number、boolean、array、object、symbol、date、regexp、function、asyncfunction、arguments、set、map、weakset、weakmap
```

```js
function DataType(tgt, type) {
    const dataType = Object.prototype.toString.call(tgt).replace(/\[object (\w+)\]/, "$1").toLowerCase();
    return type ? dataType === type : dataType;
}
DataType("young"); // "string"
DataType(20190214); // "number"
DataType(true); // "boolean"
DataType([], "array"); // true
DataType({}, "array"); // false
```

## 校验是否为一个数字，以及该数字小数点位数是否与参数floats一致

校验规则：
+ 若参数floats有值，则校验该数字小数点后的位数。
+ 若参数floats没有值，则仅仅校验是否为数字。

```js
function isNum(value,floats=null){
    let regexp = new RegExp(`^[1-9][0-9]*.[0-9]{${floats}}$|^0.[0-9]{${floats}}$`);
    return typeof value === 'number' && floats?regexp.test(String(value)):true;
}
```

## 校验是否为非零的正整数

```js
function isInt(value,minLength=null,maxLength=undefined){
	if(!isNum(value)) return false;

	let regexp = new RegExp(`^-?[1-9][0-9]${anysicIntLength(minLength,maxLength)}$`);
	return regexp.test(value.toString());
}
```

## 判断是否手机号

```js

function isMobileNumber(e) {
  var i =
      "134,135,136,137,138,139,150,151,152,157,158,159,187,188,147,182,183,184,178",
    n = "130,131,132,155,156,185,186,145,176",
    a = "133,153,180,181,189,177,173,170",
    o = e || "",
    r = o.substring(0, 3),
    d = o.substring(0, 4),
    s =
      !!/^1\d{10}$/.test(o) &&
      (n.indexOf(r) >= 0
        ? "联通"
        : a.indexOf(r) >= 0
        ? "电信"
        : "1349" == d
        ? "电信"
        : i.indexOf(r) >= 0
        ? "移动"
        : "未知");
  return s;
}
```

## 校验是否为中国大陆手机号

```js
function isTel(value) {
	return /^1[3,4,5,6,7,8,9][0-9]{9}$/.test(value.toString());
}
```

## 校验是否为中国大陆传真或固定电话号码

```js
function isFax(str) {
	return /^([0-9]{3,4})?[0-9]{7,8}$|^([0-9]{3,4}-)?[0-9]{7,8}$/.test(str);
}
```

## 校验是否为邮箱地址

```js
function isEmail(str) {
	return /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/.test(str);
}
```

## 校验是否为QQ号码

校验规则：
+ 非0开头的5位-13位整数

```js
function isQQ(value) {
	return /^[1-9][0-9]{4,12}$/.test(value.toString());
}

```

## 校验是否为中国大陆第二代居民身份证
校验规则：
+ 共18位，最后一位可为X(大小写均可)
+ 不能以0开头
+ 出生年月日会进行校验：年份只能为18/19/2*开头，月份只能为01-12，日只能为01-31

```js
function isIDCard(str){
	return /^[1-9][0-9]{5}(18|19|(2[0-9]))[0-9]{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)[0-9]{3}[0-9Xx]$/.test(str);
}
```

## 校验是否为中国大陆邮政编码

校验规则：
+ 共6位，且不能以0开头

```js
function isPostCode(value){
	return /^[1-9][0-9]{5}$/.test(value.toString());
}
```

## 判断是否移动设备访问

```js
function isMobileUserAgent() {
  return /iphone|ipod|android.*mobile|windows.*phone|blackberry.*mobile/i.test(
    window.navigator.userAgent.toLowerCase()
  );
}
```

## 判断是否为网址

```js

function isURL(strUrl) {
  var regular = /^\b(((https?|ftp):\/\/)?[-a-z0-9]+(\.[-a-z0-9]+)*\.(?:com|edu|gov|int|mil|net|org|biz|info|name|museum|asia|coop|aero|[a-z][a-z]|((25[0-5])|(2[0-4]\d)|(1\d\d)|([1-9]\d)|\d))\b(\/[-a-z0-9_:\@&?=+,.!\/~%\$]*)?)$/i;
  if (regular.test(strUrl)) {
    return true;
  } else {
    return false;
  }
}
```

## 校验字符串构成的种类数量是否大于或等于参数num的值。 

通常用来校验用户设置的密码复杂程度。

校验规则 ：
+ 参数num为需要构成的种类(字母、数字、标点符号)，该值只能是1-3。
+ 默认参数num的值为1，即表示：至少包含字母，数字，标点符号中的1种
+ 若参数num的值为2，即表示：至少包含字母，数字，标点符号中的2种
+ 若参数num的值为3，即表示：必须同时包含字母，数字，标点符号
+ 参数punctuation指可接受的标点符号集，具体设定可参考getLIPTypes()方法中关于标点符号集的解释。

```js
function anysicPunctuation(str){
    if(!str) return null;
    let arr = str.split('').map(item => {
        return item = '\\' + item;
    });
    return arr.join('|');
}
```

```js

function getPunctuation(str){
  return anysicPunctuation(str) || '\\~|\\`|\\!|\\@|\\#|\\$|\\%|\\^|\\&|\\*|\\(|\\)|\\-|\\_|\\+|\\=|\\||\\\|\\[|\\]|\\{|\\}|\\;|\\:|\\"|\\\'|\\,|\\<|\\.|\\>|\\/|\\?';
}
```

```js
function pureLIP(str,num=1,punctuation=null){
  let regexp = new RegExp(`[^A-z0-9|${getPunctuation(punctuation)}]`);
  return Boolean(!regexp.test(str) && getLIPTypes(str,punctuation)>= num);
}
```

## 设置cookie值

```js

function setCookie(name, value, Hours) {
  var d = new Date();
  var offset = 8;
  var utc = d.getTime() + d.getTimezoneOffset() * 60000;
  var nd = utc + 3600000 * offset;
  var exp = new Date(nd);
  exp.setTime(exp.getTime() + Hours * 60 * 60 * 1000);
  document.cookie =
    name +
    "=" +
    escape(value) +
    ";path=/;expires=" +
    exp.toGMTString() +
    ";domain=360doc.com;";
}
```
## keyboard

```js
(_=>[..."`1234567890-=~~QWERTYUIOP[]\\~ASDFGHJKL;'~~ZXCVBNM,./~"].map(x=>(o+=`/${b='_'.repeat(w=x<y?2:' 667699'[x=["Bs","Tab","Caps","Enter"][p++]||'Shift',p])}\\|`,m+=y+(x+'    ').slice(0,w)+y+y,n+=y+b+y+y,l+=' __'+b)[73]&&(k.push(l,m,n,o),l='',m=n=o=y),m=n=o=y='|',p=l=k=[])&&k.join`
`)()
```

## 数组排序

```js
/**
 * 根据数组中的某一属性的值（数字）进行升序或降序排序
 * @param { string } property  排序所依赖的属性
 * @param { string } flag  "asc"：升序  "desc": 降序
 * 调用方式：arr.sort(sortCompare('age','asc')); 
 * 这里的 arr 为准备排序的数组
 */
function sortCompare(property,flag){
  return function(a,b){
    var value1 = a[property];
    var value2 = b[property];
    if(flag === "asc"){
      return value1 - value2;
    } else if (flag === "desc"){
      return value2 - value1;
    }
  }
}
```
## 加法函数（精度丢失问题）
```js
/**
 * 加法函数（精度丢失问题）
 * @param { number } arg1
 * @param { number } arg2
 */
export function add(arg1, arg2) {
    let r1, r2, m;
    try { r1 = arg1.toString().split(".")[1].length } catch (e) { r1 = 0 }
    try { r2 = arg2.toString().split(".")[1].length } catch (e) { r2 = 0 }
    m = Math.pow(10, Math.max(r1, r2));
    return (arg1 * m + arg2 * m) / m
}
```

## 减法函数（精度丢失问题）

```js
/**
 * 减法函数（精度丢失问题）
 * @param { number } arg1
 * @param { number } arg2
 */
export function sub(arg1, arg2) {
    let r1, r2, m, n;
    try { r1 = arg1.toString().split(".")[1].length } catch (e) { r1 = 0 }
    try { r2 = arg2.toString().split(".")[1].length } catch (e) { r2 = 0 }
    m = Math.pow(10, Math.max(r1, r2));
    n = (r1 >= r2) ? r1 : r2;
    return Number(((arg1 * m - arg2 * m) / m).toFixed(n));
}
```
## 除法函数（精度丢失问题）

```js
/**
 * 除法函数（精度丢失问题）
 * @param { number } num1
 * @param { number } num2
 */
export function division(num1,num2){
    let t1,t2,r1,r2;
    try{
        t1 = num1.toString().split('.')[1].length;
    }catch(e){
        t1 = 0;
    }
    try{
        t2=num2.toString().split(".")[1].length;
    }catch(e){
        t2=0;
    }
    r1=Number(num1.toString().replace(".",""));
    r2=Number(num2.toString().replace(".",""));
    return (r1/r2)*Math.pow(10,t2-t1);
}
```

## 乘法函数（精度丢失问题）

```js
/**
 * 乘法函数（精度丢失问题）
 * @param { number } num1
 * @param { number } num2
 */
export function mcl(num1,num2){
    let m=0,s1=num1.toString(),s2=num2.toString();
    try{m+=s1.split(".")[1].length}catch(e){}
    try{m+=s2.split(".")[1].length}catch(e){}
    return Number(s1.replace(".",""))*Number(s2.replace(".",""))/Math.pow(10,m);
}
```