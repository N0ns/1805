# 公共方法


## es6中的find filter 在数组中查找对象

~~~js
var aa=[{id:1,name:'张三'},{id:2,name:'李四'},{id:3,name:'王五'},{id:2,name:'赵六'}]
~~~


+ 数组的方法find

~~~js
aa.find( t=> t.id=='2')  
console.log(bb)// 结果：{id:2,name:'李四'}
// find只会返回第一个满足条件的 而且返回的是对象
~~~

+ 数组的方法filter

~~~js
let bb = aa.filter( t=> t.id=='2')
console.log(bb)  // 结果 [{id:2,name:'李四'},{id:2,name:'赵六'}]
// filter会满足所有符合条件的   返回的还是数组
~~~

## 原生

```js

function removeItem(src, cb) {
 
  var counter = src.length - 1;

  while (true) {

      var result = cb(src[counter]);

      if (result) {

          src.splice(counter, 1);

          counter = src.length - 1;
      } else {
          counter--;
      }

      if (counter < 0) {
          break;
      }
  }
}

var testData = [1, 2, 3, 5, 5, 6, 6, 7, 8, 9, 10];

removeItem(testData, c => c % 2 == 0);

console.log(testData);
```

## 求两个数组的差集

原生

```js
const exclude = (select = [], exclude = []) => {
  for (var i = 0; i < exclude.length; i++) {
    for (var j = 0; j < select.length; j++) {
      if (select[j] == exclude[i]) {
        select.splice(j, 1)
        j = j - 1
      }
    }
  }
  return select
}

```

ES6

```js
const subSet = (arr1, arr2) => {
  var set1 = new Set(arr1)
  var set2 = new Set(arr2)

  var subset = []

  for (const item of set1) {
    if (!set2.has(item)) {
      subset.push(item)
    }
  }

  return subset
}
```

## 求两个数组的交集

```js
var arr1 = [0,2,3,4,6,7,9]
var arr2 = [1,2,3,5,6,8]

var res = [...new Set(arr1)].filter(item => arr2.includes(item))
console.log(res)
```

## 美化金钱

```js
const ThousandNum = num => num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
const money = ThousandNum(20190214);
// money => "20,190,214"
```

## 操作URL查询参数

```js
const params = new URLSearchParams(location.search.replace(/\?/ig, "")); // location.search = "?name=young&sex=male"
params.has("young"); // true
params.get("sex"); // "male"
```

## 时间戳

```js
const timestamp = +new Date("2019-02-14");
// timestamp => 155010240000
```

## 精确小数

```js
const RoundNum = (num, decimal) => Math.round(num * 10 ** decimal) / 10 ** decimal;
const num = RoundNum(1.69, 1);
// num => 1.7
```

## 是否空对象

```js
const obj = {};
const flag = DataType(obj, "object") && !Object.keys(obj).length;
// flag => true
```

## 满足条件时执行

```js
const flagA = true; // 条件A
const flagB = false; // 条件B
(flagA || flagB) && Func(); // 满足A或B时执行
(flagA || !flagB) && Func(); // 满足A或不满足B时执行
flagA && flagB && Func(); // 同时满足A和B时执行
flagA && !flagB && Func(); // 满足A且不满足B时执行
```

## 对象不为空时执行

```js
const obj = { a: 0, b: 1, c: 2 };
Object.keys(obj).length && Func();
```

## 函数退出代替条件分支退出

```js
if (flag) {
    Func();
    return false;
}
// 换成
if (flag) {
    return Func();
}
```

## switch/case使用区间

```js
const age = 26;
switch (true) {
    case isNaN(age):
        console.log("not a number");
        break;
    case (age < 18):
        console.log("under age");
        break;
    case (age >= 18):
        console.log("adult");
        break;
    default:
        console.log("please set your age");
        break;
}
```

## 克隆对象

```js
const _obj = { a: 0, b: 1, c: 2 }; // 以下方法任选一种
const obj = { ..._obj };
```

## 环境变量

```js
const env = "prod";
const link = {
    dev: "Development Address",
    test: "Testing Address",
    prod: "Production Address"
}[env];
// link => "Production Address"
```

## 解构对象属性嵌套

```js
const obj = { a: 0, b: 1, c: { d: 2, e: 3 } };
const { c: { d, e } } = obj;
// d e => 2 3
```

## keyboard

```js
(_=>[..."`1234567890-=~~QWERTYUIOP[]\\~ASDFGHJKL;'~~ZXCVBNM,./~"].map(x=>(o+=`/${b='_'.repeat(w=x<y?2:' 667699'[x=["Bs","Tab","Caps","Enter"][p++]||'Shift',p])}\\|`,m+=y+(x+'    ').slice(0,w)+y+y,n+=y+b+y+y,l+=' __'+b)[73]&&(k.push(l,m,n,o),l='',m=n=o=y),m=n=o=y='|',p=l=k=[])&&k.join`
`)()
```
